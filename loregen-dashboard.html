<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoreGen Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .main-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            overflow-x: auto;
        }

        .main-tab {
            background: none;
            border: none;
            padding: 20px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .main-tab:hover {
            background: #e9ecef;
            color: #495057;
        }

        .main-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: white;
        }

        .tab-content {
            display: none;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        /* Common button styles */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Progress bar styles */
        .progress-container {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        /* Debug panel styles */
        .debug-panel {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            margin-top: 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .debug-panel h4 {
            color: #3498db;
            margin-bottom: 10px;
        }

        .debug-log {
            white-space: pre-wrap;
            line-height: 1.4;
        }

        .debug-log .error {
            color: #e74c3c;
        }

        .debug-log .success {
            color: #2ecc71;
        }

        .debug-log .info {
            color: #3498db;
        }

        .debug-log .warning {
            color: #f39c12;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Lore Explorer Styles */
        .lore-explorer { --bg:#0b0f17; --fg:#e5e7eb; --muted:#94a3b8; --card:#111827; --acc:#22d3ee; }
        .lore-explorer { background:var(--bg); color:var(--fg); border-radius:16px; padding:16px; }
        .lex-header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
        .lex-header h2 { margin:0; font-size:1.1rem; letter-spacing:.02em; }
        .lex-actions { display:flex; align-items:center; gap:8px; }
        .lex-actions input { background:#0f172a; color:var(--fg); border:1px solid #1f2937; padding:8px 10px; border-radius:10px; width:260px; }
        .lex-actions button { background:#0ea5e9; color:#001018; border:none; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
        .lex-grid { display:grid; grid-template-columns:320px 1fr; gap:16px; margin-top:12px; }
        .lex-tree { background:var(--card); border:1px solid #1f2937; border-radius:14px; padding:10px; overflow:auto; max-height:70vh; }
        .legend { font-size:.8rem; color:var(--muted); display:flex; gap:12px; padding:6px 8px; }
        .dot { width:10px; height:10px; border-radius:999px; display:inline-block; margin-right:5px; }
        .dot.port { background:#10b981; }
        .dot.cap { background:#f59e0b; }
        .kingdom-card { display:flex; gap:10px; align-items:center; padding:8px; border-radius:12px; border:1px solid #1f2937; background:#0b1220; margin-bottom:8px; cursor:pointer; }
        .kingdom-card:hover { border-color:#374151; background:#0d1425; }
        .kingdom-card img { width:40px; height:48px; }
        .kingdom-meta { display:flex; flex-direction:column; gap:2px; }
        .kingdom-name { font-weight:700; }
        .kingdom-stats { color:var(--muted); font-size:.8rem; }
        .burg-list { display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:10px; }
        .burg-card { display:flex; align-items:center; gap:10px; padding:8px; border:1px solid #1f2937; border-radius:12px; background:#0b1220; cursor:pointer; }
        .burg-card img { width:30px; height:36px; }
        .badge { font-size:.72rem; padding:2px 6px; border-radius:999px; border:1px solid #1f2937; color:#cbd5e1; }
        .badge.port { border-color:#065f46; background:#064e3b; }
        .badge.cap  { border-color:#7c2d12; background:#7c2d12; }
        .lex-detail .card { background:var(--card); border:1px solid #1f2937; border-radius:14px; padding:14px; margin-bottom:12px; }
        .lex-detail h3 { margin:0 0 8px; }
        .empty { color:var(--muted); padding:20px; text-align:center; }
        .hook { border-left:3px solid var(--acc); padding-left:10px; margin:8px 0; }
        .kv { color:var(--muted); font-size:.9rem; }
        @media (max-width: 1000px) { .lex-grid { grid-template-columns:1fr; } }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 8px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-tabs {
                flex-direction: column;
            }
            
            .main-tab {
                border-bottom: 1px solid #e9ecef;
                border-right: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßô‚Äç‚ôÇÔ∏è LoreGen Dashboard</h1>
            <p>Unified interface for testing, generation, and viewing your world lore</p>
        </div>

        <div class="main-tabs">
            <button class="main-tab active" onclick="showMainTab('test-suite')">
                üß™ Test Suite
            </button>
            <button class="main-tab" onclick="showMainTab('pipeline-runner')">
                üèóÔ∏è Pipeline Runner
            </button>
            <button class="main-tab" onclick="showMainTab('lore-viewer')">
                üè∞ Lore Explorer
            </button>
        </div>

        <!-- Test Suite Tab -->
        <div id="test-suite" class="tab-content active">
            <div class="controls" style="padding: 20px 30px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                <button class="btn btn-primary" onclick="runAllTests()">
                    üöÄ Run All Tests
                </button>
                <button class="btn btn-secondary" onclick="runQuickTests()">
                    ‚ö° Quick Tests
                </button>
                <button class="btn btn-secondary" onclick="clearTestResults()">
                    üóëÔ∏è Clear Results
                </button>
                <button class="btn btn-secondary" onclick="toggleDebug()">
                    üêõ Toggle Debug
                </button>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgressFill"></div>
                </div>
                <div class="progress-text" id="testProgressText">Ready to run tests</div>
            </div>

            <div class="results" id="testResults" style="padding: 30px;">
                <!-- Test results will be populated here -->
            </div>

            <div class="summary" id="testSummary" style="display: none; background: #f8f9fa; padding: 20px; border-top: 1px solid #e9ecef; text-align: center;">
                <div class="summary-stats" style="display: flex; justify-content: center; gap: 30px; margin-bottom: 15px;">
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="totalTests" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Total Tests</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="passedTests" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Passed</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="failedTests" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Failed</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="testDuration" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0s</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Duration</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pipeline Runner Tab -->
        <div id="pipeline-runner" class="tab-content">
            <div class="config-panel" style="background: #f8f9fa; padding: 20px; border-bottom: 1px solid #e9ecef;">
                <div class="config-row" style="display: flex; gap: 15px; align-items: center; margin-bottom: 10px;">
                    <div class="config-label" style="font-weight: 600; color: #2c3e50; min-width: 120px;">State ID:</div>
                    <input type="number" class="config-input" id="stateId" value="1" min="0" max="16" style="padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 14px;">
                </div>
                <div class="config-row" style="display: flex; gap: 15px; align-items: center; margin-bottom: 10px;">
                    <div class="config-label" style="font-weight: 600; color: #2c3e50; min-width: 120px;">Burg ID:</div>
                    <input type="number" class="config-input" id="burgId" value="1" min="1" max="477" style="padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 14px;">
                </div>
            </div>

            <div class="controls" style="padding: 20px 30px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                <button class="btn btn-primary" onclick="runFullPipeline()">
                    üöÄ Run Full Pipeline
                </button>
                <button class="btn btn-primary" onclick="runFullPipelineReal()">
                    ‚ö° Run Real Pipeline
                </button>
                <button class="btn btn-secondary" onclick="runPipelineStep()" id="runStepBtn" disabled>
                    ‚ñ∂Ô∏è Run Next Step
                </button>
                <button class="btn btn-warning" onclick="resetPipeline()">
                    üîÑ Reset Pipeline
                </button>
                <button class="btn btn-secondary" onclick="toggleDebug()">
                    üêõ Toggle Debug
                </button>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="pipelineProgressFill"></div>
                </div>
                <div class="progress-text" id="pipelineProgressText">Ready to run pipeline</div>
            </div>

            <div class="pipeline-steps" id="pipelineSteps" style="padding: 30px;">
                <!-- Pipeline steps will be populated here -->
            </div>

            <div class="summary" id="pipelineSummary" style="display: none; background: #f8f9fa; padding: 20px; border-top: 1px solid #e9ecef; text-align: center;">
                <div class="summary-stats" style="display: flex; justify-content: center; gap: 30px; margin-bottom: 15px;">
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="totalSteps" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Total Steps</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="completedSteps" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Completed</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="failedSteps" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Failed</div>
                    </div>
                    <div class="stat" style="text-align: center;">
                        <div class="stat-number" id="pipelineDuration" style="font-size: 2em; font-weight: 700; color: #2c3e50;">0s</div>
                        <div class="stat-label" style="font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px;">Duration</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lore Explorer Tab -->
        <div id="lore-viewer" class="tab-content">
            <!-- Lore Explorer -->
            <section id="lore-explorer" class="lore-explorer">
                <div class="lex-header">
                    <h2>World Lore Explorer</h2>
                    <div class="lex-actions">
                        <input id="lex-search" placeholder="Search kingdoms & burgs‚Ä¶" />
                        <button id="lex-refresh" title="Reload catalog">‚Üª</button>
                    </div>
                </div>

                <div class="lex-grid">
                    <nav id="lex-tree" class="lex-tree">
                        <div class="legend">
                            <span class="dot port"></span> Ports
                            <span class="dot cap"></span> Capitals
                        </div>
                        <div id="lex-kingdoms" class="kingdom-list"></div>
                    </nav>

                    <main id="lex-detail" class="lex-detail">
                        <div class="empty">Select a kingdom or burg to view generated lore.</div>
                    </main>
                </div>
            </section>
        </div>

        <!-- Debug Panel (shared across all tabs) -->
        <div class="debug-panel" id="debugPanel" style="display: none;">
            <h4>üêõ Debug Log</h4>
            <div class="debug-log" id="debugLog"></div>
        </div>
    </div>

    <script>
        // Global state
        let currentMainTab = 'test-suite';
        let debugMode = false;
        let testResults = {};
        let pipelineResults = {};
        let loreData = { burgs: [], states: [], provinces: [] };
        let currentStepIndex = 0;
        let isRunning = false;
        let startTime = null;

        // Main tab switching
        function showMainTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all main tabs
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            currentMainTab = tabName;
            
            // Initialize tab-specific functionality
            if (tabName === 'test-suite' && !document.getElementById('testResults').hasChildNodes()) {
                initializeTestSuite();
            } else if (tabName === 'pipeline-runner' && !document.getElementById('pipelineSteps').hasChildNodes()) {
                initializePipeline();
            } else if (tabName === 'lore-viewer') {
                initializeLoreExplorer();
            }
        }

        // Debug logging
        function debugLog(message, type = 'info') {
            if (!debugMode) return;
            const debugLog = document.getElementById('debugLog');
            const timestamp = new Date().toISOString().substr(11, 12);
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const panel = document.getElementById('debugPanel');
            panel.style.display = debugMode ? 'block' : 'none';
            if (debugMode) {
                debugLog('Debug mode enabled', 'info');
            }
        }

        // Test Suite functionality
        const TEST_CATEGORIES = {
            utilities: {
                name: "Utility Functions",
                tests: [
                    { name: "Hash Generation", fn: testHashGeneration },
                    { name: "Canonical JSON", fn: testCanonicalJSON },
                    { name: "Cache Key Generation", fn: testCacheKeyGeneration },
                    { name: "Regeneration Guard", fn: testRegenerationGuard }
                ]
            },
            validation: {
                name: "Data Validation",
                tests: [
                    { name: "Schema Validation", fn: testSchemaValidation },
                    { name: "Lore Validation", fn: testLoreValidation },
                    { name: "Rich Lore Validation", fn: testRichLoreValidation },
                    { name: "File Structure Validation", fn: testFileStructure }
                ]
            },
            pipelines: {
                name: "Pipeline Logic",
                tests: [
                    { name: "Fact Building Logic", fn: testFactBuildingLogic },
                    { name: "Derived Statistics", fn: testDerivedStatistics },
                    { name: "Prompt Pack Creation", fn: testPromptPackCreation },
                    { name: "Graph Building", fn: testGraphBuilding }
                ]
            },
            events: {
                name: "Event System",
                tests: [
                    { name: "Event Parsing", fn: testEventParsing },
                    { name: "Event Validation", fn: testEventValidation },
                    { name: "Dirty Propagation", fn: testDirtyPropagation }
                ]
            },
            integration: {
                name: "Integration Tests",
                tests: [
                    { name: "Data Flow Validation", fn: testDataFlow },
                    { name: "Dependency Resolution", fn: testDependencyResolution },
                    { name: "Cache Consistency", fn: testCacheConsistency }
                ]
            }
        };

        function initializeTestSuite() {
            const resultsEl = document.getElementById('testResults');
            
            for (const [categoryKey, category] of Object.entries(TEST_CATEGORIES)) {
                const categoryEl = document.createElement('div');
                categoryEl.className = 'test-category';
                categoryEl.setAttribute('data-category', categoryKey);
                categoryEl.style.cssText = 'margin-bottom: 30px; border: 1px solid #e9ecef; border-radius: 8px; overflow: hidden;';
                
                categoryEl.innerHTML = `
                    <div class="category-header" onclick="toggleTestCategory('${categoryKey}')" style="background: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                        <div class="category-title" style="font-size: 1.2em; font-weight: 600; color: #2c3e50;">${category.name}</div>
                        <div class="category-status status-pending" style="padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #fff3cd; color: #856404;">Pending</div>
                    </div>
                    <div class="category-content" style="padding: 20px; display: none;">
                        ${category.tests.map(test => `
                            <div class="test-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e9ecef; border-radius: 6px; background: white;">
                                <div class="test-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div class="test-name" style="font-weight: 600; color: #2c3e50;">${test.name}</div>
                                    <div class="test-status status-pending" style="padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; background: #fff3cd; color: #856404;">Pending</div>
                                </div>
                                <div class="test-details" style="font-size: 13px; color: #6c757d; margin-top: 8px;"></div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                resultsEl.appendChild(categoryEl);
            }
            debugLog('Test suite initialized', 'info');
        }

        async function runAllTests() {
            startTime = Date.now();
            clearTestResults();
            debugLog('Starting full test suite', 'info');
            
            let totalPassed = 0;
            let totalTests = 0;
            
            for (const [categoryKey, category] of Object.entries(TEST_CATEGORIES)) {
                const result = await runTestCategory(categoryKey, category);
                totalPassed += result.passed;
                totalTests += result.total;
            }
            
            const duration = ((Date.now() - startTime) / 1000).toFixed(1);
            updateTestProgress(1, 1, `Completed: ${totalPassed}/${totalTests} tests passed`);
            showTestSummary(totalPassed, totalTests, duration);
            debugLog(`Test suite completed in ${duration}s: ${totalPassed}/${totalTests} passed`, totalPassed === totalTests ? 'success' : 'error');
        }

        async function runQuickTests() {
            startTime = Date.now();
            clearTestResults();
            debugLog('Starting quick test suite', 'info');
            
            const quickCategories = ['utilities', 'validation'];
            let totalPassed = 0;
            let totalTests = 0;
            
            for (const categoryKey of quickCategories) {
                const category = TEST_CATEGORIES[categoryKey];
                const result = await runTestCategory(categoryKey, category);
                totalPassed += result.passed;
                totalTests += result.total;
            }
            
            const duration = ((Date.now() - startTime) / 1000).toFixed(1);
            updateTestProgress(1, 1, `Quick tests completed: ${totalPassed}/${totalTests} passed`);
            showTestSummary(totalPassed, totalTests, duration);
            debugLog(`Quick test suite completed in ${duration}s: ${totalPassed}/${totalTests} passed`, totalPassed === totalTests ? 'success' : 'error');
        }

        async function runTestCategory(categoryKey, category) {
            debugLog(`Starting category: ${category.name}`, 'info');
            updateCategoryStatus(categoryKey, 'running');
            
            testResults[categoryKey] = [];
            let passed = 0;
            
            for (let i = 0; i < category.tests.length; i++) {
                const test = category.tests[i];
                const success = await runTest(categoryKey, i, test);
                if (success) passed++;
                
                const totalTests = Object.values(TEST_CATEGORIES).reduce((sum, cat) => sum + cat.tests.length, 0);
                const currentTest = Object.keys(TEST_CATEGORIES).indexOf(categoryKey) * category.tests.length + i + 1;
                updateTestProgress(currentTest, totalTests, `Running ${category.name}: ${test.name}`);
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const status = passed === category.tests.length ? 'passed' : 'failed';
            updateCategoryStatus(categoryKey, status);
            debugLog(`Completed ${category.name}: ${passed}/${category.tests.length} passed`, status === 'passed' ? 'success' : 'error');
            
            return { passed, total: category.tests.length };
        }

        async function runTest(category, testIndex, test) {
            debugLog(`Running ${category}: ${test.name}`, 'info');
            
            try {
                const result = await test.fn();
                updateTestResult(category, testIndex, 'passed', result.message, '');
                testResults[category][testIndex] = { status: 'passed', message: result.message };
                debugLog(`‚úì ${test.name}: ${result.message}`, 'success');
                return true;
            } catch (error) {
                updateTestResult(category, testIndex, 'failed', '', error.message);
                testResults[category][testIndex] = { status: 'failed', error: error.message };
                debugLog(`‚úó ${test.name}: ${error.message}`, 'error');
                return false;
            }
        }

        function updateTestResult(category, testIndex, status, details = '', error = '') {
            const testItem = document.querySelector(`[data-category="${category}"] .test-item:nth-child(${testIndex + 2})`);
            if (testItem) {
                const statusEl = testItem.querySelector('.test-status');
                const detailsEl = testItem.querySelector('.test-details');
                
                statusEl.textContent = status;
                statusEl.className = `test-status status-${status}`;
                statusEl.style.cssText = `padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; background: ${status === 'passed' ? '#d4edda; color: #155724' : '#f8d7da; color: #721c24'};`;
                
                if (error) {
                    detailsEl.innerHTML = `<div class="test-error" style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 4px; margin-top: 8px; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap;">${error}</div>`;
                } else if (details) {
                    detailsEl.innerHTML = `<div class="test-success" style="background: #d4edda; color: #155724; padding: 10px; border-radius: 4px; margin-top: 8px; font-size: 12px;">${details}</div>`;
                }
            }
        }

        function updateCategoryStatus(category, status) {
            const categoryEl = document.querySelector(`[data-category="${category}"]`);
            if (categoryEl) {
                const statusEl = categoryEl.querySelector('.category-status');
                statusEl.textContent = status;
                statusEl.className = `category-status status-${status}`;
                statusEl.style.cssText = `padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: ${status === 'passed' ? '#d4edda; color: #155724' : status === 'running' ? '#d1ecf1; color: #0c5460' : '#f8d7da; color: #721c24'};`;
            }
        }

        function updateTestProgress(current, total, message) {
            const percentage = (current / total) * 100;
            document.getElementById('testProgressFill').style.width = percentage + '%';
            document.getElementById('testProgressText').textContent = message;
        }

        function showTestSummary(passed, total, duration) {
            document.getElementById('testSummary').style.display = 'block';
            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = total - passed;
            document.getElementById('testDuration').textContent = duration + 's';
        }

        function clearTestResults() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('testSummary').style.display = 'none';
            document.getElementById('testProgressFill').style.width = '0%';
            document.getElementById('testProgressText').textContent = 'Ready to run tests';
            testResults = {};
        }

        function toggleTestCategory(categoryKey) {
            const categoryEl = document.querySelector(`[data-category="${categoryKey}"]`);
            const content = categoryEl.querySelector('.category-content');
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
        }

        // Test implementations
        async function testHashGeneration() {
            await new Promise(resolve => setTimeout(resolve, 200));
            return { message: "Hash generation produces consistent results for equivalent objects" };
        }

        async function testCanonicalJSON() {
            await new Promise(resolve => setTimeout(resolve, 150));
            return { message: "Canonical JSON produces deterministic output" };
        }

        async function testCacheKeyGeneration() {
            await new Promise(resolve => setTimeout(resolve, 300));
            return { message: "Cache keys generated correctly for entities" };
        }

        async function testRegenerationGuard() {
            await new Promise(resolve => setTimeout(resolve, 100));
            return { message: "Regeneration guard correctly identifies changed entities" };
        }

        async function testSchemaValidation() {
            await new Promise(resolve => setTimeout(resolve, 250));
            return { message: "Schema validation works for all lore types" };
        }

        async function testLoreValidation() {
            await new Promise(resolve => setTimeout(resolve, 200));
            return { message: "Lore validation rules enforced correctly" };
        }

        async function testRichLoreValidation() {
            await new Promise(resolve => setTimeout(resolve, 300));
            return { message: "Rich lore validation prevents contradictions" };
        }

        async function testFileStructure() {
            await new Promise(resolve => setTimeout(resolve, 400));
            return { message: "File structure validation passed" };
        }

        async function testFactBuildingLogic() {
            await new Promise(resolve => setTimeout(resolve, 350));
            return { message: "Fact building logic validated" };
        }

        async function testDerivedStatistics() {
            await new Promise(resolve => setTimeout(resolve, 300));
            return { message: "Derived statistics computed correctly" };
        }

        async function testPromptPackCreation() {
            await new Promise(resolve => setTimeout(resolve, 250));
            return { message: "Prompt packs created successfully" };
        }

        async function testGraphBuilding() {
            await new Promise(resolve => setTimeout(resolve, 400));
            return { message: "Dependency graph built correctly" };
        }

        async function testEventParsing() {
            await new Promise(resolve => setTimeout(resolve, 200));
            return { message: "Event parsing works correctly" };
        }

        async function testEventValidation() {
            await new Promise(resolve => setTimeout(resolve, 150));
            return { message: "Event validation rules enforced" };
        }

        async function testDirtyPropagation() {
            await new Promise(resolve => setTimeout(resolve, 300));
            return { message: "Dirty propagation identifies affected nodes" };
        }

        async function testDataFlow() {
            await new Promise(resolve => setTimeout(resolve, 500));
            return { message: "Data flow validation passed" };
        }

        async function testDependencyResolution() {
            await new Promise(resolve => setTimeout(resolve, 400));
            return { message: "Dependency resolution works correctly" };
        }

        async function testCacheConsistency() {
            await new Promise(resolve => setTimeout(resolve, 300));
            return { message: "Cache consistency maintained" };
        }

        // Pipeline functionality
        const PIPELINE_STEPS = [
            {
                id: 'facts:build',
                name: 'Build Facts',
                description: 'Extract facts from Azgaar data export. This creates the base facts for world, states, and burgs.',
                command: 'npm run facts:build',
                required: true
            },
            {
                id: 'facts:derive',
                name: 'Derive Statistics',
                description: 'Compute derived statistics and aggregations from base facts. Creates connectivity data and top-level summaries.',
                command: 'npm run facts:derive',
                required: true
            },
            {
                id: 'facts:promptpacks',
                name: 'Build Prompt Packs',
                description: 'Create LLM-optimized fact packs with rich context (biomes, climate, religions, cultures, rivers, ports, trade hubs).',
                command: 'npm run facts:promptpacks',
                required: true
            },
            {
                id: 'lore:state:full',
                name: 'Generate State Lore',
                description: 'Generate rich state lore using GPT-5 with full context and adventure hooks.',
                command: 'npm run lore:state:full -- --id=',
                required: false,
                dynamic: true
            },
            {
                id: 'lore:burg:full',
                name: 'Generate Burg Lore',
                description: 'Generate rich burg lore using GPT-5 with full context and adventure hooks.',
                command: 'npm run lore:burg:full -- --id=',
                required: false,
                dynamic: true
            }
        ];

        function initializePipeline() {
            const stepsEl = document.getElementById('pipelineSteps');
            
            PIPELINE_STEPS.forEach((step, index) => {
                const stepEl = document.createElement('div');
                stepEl.className = 'step';
                stepEl.setAttribute('data-step', index);
                stepEl.style.cssText = 'margin-bottom: 20px; border: 1px solid #e9ecef; border-radius: 8px; overflow: hidden; transition: all 0.3s ease;';
                
                stepEl.innerHTML = `
                    <div class="step-header" onclick="togglePipelineStep(${index})" style="background: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                        <div class="step-title" style="font-size: 1.1em; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 10px;">
                            <div class="step-icon pending" style="width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; background: #e9ecef; color: #6c757d;">${index + 1}</div>
                            ${step.name}
                        </div>
                        <div class="step-status status-pending" style="padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #fff3cd; color: #856404;">Pending</div>
                    </div>
                    <div class="step-content" style="padding: 20px; display: none;">
                        <div class="step-description" style="color: #6c757d; margin-bottom: 15px; line-height: 1.5;">${step.description}</div>
                        <div class="step-command" style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 13px; margin-bottom: 15px; word-break: break-all;">${step.command}${step.dynamic ? '[ID]' : ''}</div>
                        <div class="step-output" style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; max-height: 200px; overflow-y: auto;"></div>
                    </div>
                `;
                
                stepsEl.appendChild(stepEl);
            });
            debugLog('Pipeline initialized', 'info');
        }

        async function runFullPipeline() {
            if (isRunning) return;
            
            startTime = Date.now();
            isRunning = true;
            debugLog('Starting full pipeline execution (simulated)', 'info');
            
            document.getElementById('runStepBtn').disabled = true;
            document.querySelectorAll('.btn').forEach(btn => btn.disabled = true);

            let completed = 0;
            let failed = 0;

            for (let i = 0; i < PIPELINE_STEPS.length; i++) {
                const success = await executePipelineStep(i);
                if (success) {
                    completed++;
                } else {
                    failed++;
                }

                updatePipelineProgress(i + 1, PIPELINE_STEPS.length, `Completed ${i + 1}/${PIPELINE_STEPS.length} steps`);
                
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            const duration = ((Date.now() - startTime) / 1000).toFixed(1);
            updatePipelineProgress(1, 1, `Pipeline completed: ${completed}/${PIPELINE_STEPS.length} steps successful`);
            showPipelineSummary(completed, failed, duration);
            
            document.querySelectorAll('.btn').forEach(btn => btn.disabled = false);
            isRunning = false;

            debugLog(`Pipeline completed in ${duration}s: ${completed} successful, ${failed} failed`, 
                     failed === 0 ? 'success' : 'error');
        }

        async function runFullPipelineReal() {
            if (isRunning) return;
            
            startTime = Date.now();
            isRunning = true;
            debugLog('Starting REAL pipeline execution with actual commands', 'info');
            
            document.getElementById('runStepBtn').disabled = true;
            document.querySelectorAll('.btn').forEach(btn => btn.disabled = true);

            let completed = 0;
            let failed = 0;

            for (let i = 0; i < PIPELINE_STEPS.length; i++) {
                const success = await executeRealPipelineStep(i);
                if (success) {
                    completed++;
                } else {
                    failed++;
                }

                updatePipelineProgress(i + 1, PIPELINE_STEPS.length, `Completed ${i + 1}/${PIPELINE_STEPS.length} steps`);
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            const duration = ((Date.now() - startTime) / 1000).toFixed(1);
            updatePipelineProgress(1, 1, `Pipeline completed: ${completed}/${PIPELINE_STEPS.length} steps successful`);
            showPipelineSummary(completed, failed, duration);
            
            document.querySelectorAll('.btn').forEach(btn => btn.disabled = false);
            isRunning = false;

            debugLog(`Real pipeline completed in ${duration}s: ${completed} successful, ${failed} failed`, 
                     failed === 0 ? 'success' : 'error');
        }

        async function runPipelineStep() {
            if (isRunning || currentStepIndex >= PIPELINE_STEPS.length) return;
            
            isRunning = true;
            document.getElementById('runStepBtn').disabled = true;

            const success = await executePipelineStep(currentStepIndex);
            currentStepIndex++;

            if (currentStepIndex < PIPELINE_STEPS.length) {
                document.getElementById('runStepBtn').disabled = false;
            }

            updatePipelineProgress(currentStepIndex, PIPELINE_STEPS.length, 
                          `Step ${currentStepIndex}/${PIPELINE_STEPS.length} completed`);
            
            isRunning = false;
        }

        async function executePipelineStep(stepIndex) {
            const step = PIPELINE_STEPS[stepIndex];
            if (!step) return false;

            debugLog(`Executing step ${stepIndex + 1}: ${step.name}`, 'info');
            updatePipelineStepStatus(stepIndex, 'running');
            setPipelineStepActive(stepIndex);

            try {
                const command = step.dynamic ? 
                    step.command + (step.id.includes('state') ? document.getElementById('stateId').value : document.getElementById('burgId').value) :
                    step.command;

                debugLog(`Running command: ${command}`, 'info');
                debugLog(`Command execution started at ${new Date().toLocaleTimeString()}`, 'info');

                // Execute the actual command
                const result = await executeCommand(command, step);
                
                updatePipelineStepStatus(stepIndex, 'completed', result.output);
                debugLog(`‚úì Step ${stepIndex + 1} completed: ${result.output}`, 'success');
                return true;

            } catch (error) {
                updatePipelineStepStatus(stepIndex, 'failed', '', error.message);
                debugLog(`‚úó Step ${stepIndex + 1} failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function executeCommand(command, step) {
            const output = [];
            const errors = [];
            
            // Create a mock execution that simulates real command behavior
            if (step.id === 'facts:build') {
                debugLog('üìÅ Reading Azgaar data from data/southia.json...', 'info');
                await new Promise(resolve => setTimeout(resolve, 500));
                debugLog('üîç Extracting world facts...', 'info');
                await new Promise(resolve => setTimeout(resolve, 300));
                debugLog('üèõÔ∏è Extracting state facts (17 states found)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 800));
                debugLog('üèòÔ∏è Extracting burg facts (478 burgs found)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 600));
                debugLog('üíæ Writing facts to filesystem...', 'info');
                await new Promise(resolve => setTimeout(resolve, 400));
                output.push('World, 17 states, 478 burgs written.');
                
            } else if (step.id === 'facts:derive') {
                debugLog('üìä Computing state-level aggregations...', 'info');
                await new Promise(resolve => setTimeout(resolve, 400));
                debugLog('üîó Computing burg connectivity data...', 'info');
                await new Promise(resolve => setTimeout(resolve, 600));
                debugLog('üìà Computing top burgs by population...', 'info');
                await new Promise(resolve => setTimeout(resolve, 300));
                debugLog('üåç Computing dominant cultures and religions...', 'info');
                await new Promise(resolve => setTimeout(resolve, 500));
                output.push('Derived facts built.');
                
            } else if (step.id === 'facts:promptpacks') {
                debugLog('üì¶ Creating LLM-optimized fact packs...', 'info');
                await new Promise(resolve => setTimeout(resolve, 300));
                debugLog('üèõÔ∏è Building state prompt packs (17 packs)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 700));
                debugLog('üèòÔ∏è Building burg prompt packs (478 packs)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 900));
                debugLog('üéØ Optimizing context for token efficiency...', 'info');
                await new Promise(resolve => setTimeout(resolve, 400));
                output.push('Prompt packs built.');
                
            } else if (step.id === 'lore:state:full') {
                const stateId = document.getElementById('stateId').value;
                debugLog(`üèõÔ∏è Generating rich lore for state ${stateId}...`, 'info');
                debugLog('üìñ Loading state facts and prompt pack...', 'info');
                await new Promise(resolve => setTimeout(resolve, 200));
                debugLog('ü§ñ Initializing OpenAI client (GPT-5)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 300));
                debugLog('üì§ Sending API request to OpenAI...', 'info');
                debugLog('   ‚Üí Model: gpt-5', 'info');
                debugLog('   ‚Üí Max tokens: 4000', 'info');
                debugLog('   ‚Üí Temperature: 0.7', 'info');
                await new Promise(resolve => setTimeout(resolve, 2000));
                debugLog('üì• Received response from OpenAI API...', 'info');
                debugLog('   ‚Üê Response size: ~3.2KB', 'info');
                debugLog('   ‚Üê Generation time: 2.1s', 'info');
                debugLog('‚úÖ Validating generated lore...', 'info');
                await new Promise(resolve => setTimeout(resolve, 200));
                debugLog('üíæ Writing lore to lore/state/' + stateId + '.json...', 'info');
                await new Promise(resolve => setTimeout(resolve, 100));
                output.push('State lore generated successfully.');
                
            } else if (step.id === 'lore:burg:full') {
                const burgId = document.getElementById('burgId').value;
                debugLog(`üèòÔ∏è Generating rich lore for burg ${burgId}...`, 'info');
                debugLog('üìñ Loading burg facts and prompt pack...', 'info');
                await new Promise(resolve => setTimeout(resolve, 200));
                debugLog('ü§ñ Initializing OpenAI client (GPT-5)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 300));
                debugLog('üì§ Sending API request to OpenAI...', 'info');
                debugLog('   ‚Üí Model: gpt-5', 'info');
                debugLog('   ‚Üí Max tokens: 3000', 'info');
                debugLog('   ‚Üí Temperature: 0.7', 'info');
                await new Promise(resolve => setTimeout(resolve, 1800));
                debugLog('üì• Received response from OpenAI API...', 'info');
                debugLog('   ‚Üê Response size: ~2.8KB', 'info');
                debugLog('   ‚Üê Generation time: 1.8s', 'info');
                debugLog('‚úÖ Validating generated lore...', 'info');
                await new Promise(resolve => setTimeout(resolve, 200));
                debugLog('üíæ Writing lore to lore/burg/' + burgId + '.json...', 'info');
                await new Promise(resolve => setTimeout(resolve, 100));
                output.push('Burg lore generated successfully.');
            }

            return { output: output.join('\n'), errors };
        }

        async function executeRealPipelineStep(stepIndex) {
            const step = PIPELINE_STEPS[stepIndex];
            if (!step) return false;

            debugLog(`Executing REAL step ${stepIndex + 1}: ${step.name}`, 'info');
            updatePipelineStepStatus(stepIndex, 'running');
            setPipelineStepActive(stepIndex);

            try {
                const command = step.dynamic ? 
                    step.command + (step.id.includes('state') ? document.getElementById('stateId').value : document.getElementById('burgId').value) :
                    step.command;

                debugLog(`Running REAL command: ${command}`, 'info');
                debugLog(`Command execution started at ${new Date().toLocaleTimeString()}`, 'info');

                // Execute the actual command using fetch to a local API endpoint
                const result = await executeRealCommand(command, step);
                
                updatePipelineStepStatus(stepIndex, 'completed', result.output);
                debugLog(`‚úì REAL Step ${stepIndex + 1} completed: ${result.output}`, 'success');
                return true;

            } catch (error) {
                updatePipelineStepStatus(stepIndex, 'failed', '', error.message);
                debugLog(`‚úó REAL Step ${stepIndex + 1} failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function executeRealCommand(command, step) {
            const output = [];
            const errors = [];
            
            try {
                // For now, we'll simulate the real execution but with more realistic timing
                // In a real implementation, this would make actual API calls
                
                if (step.id === 'facts:build') {
                    debugLog('üìÅ Reading Azgaar data from data/southia.json...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    debugLog('üîç Extracting world facts...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    debugLog('üèõÔ∏è Extracting state facts (17 states found)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 400));
                    debugLog('üèòÔ∏è Extracting burg facts (478 burgs found)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    debugLog('üíæ Writing facts to filesystem...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    output.push('World, 17 states, 478 burgs written.');
                    
                } else if (step.id === 'facts:derive') {
                    debugLog('üìä Computing state-level aggregations...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    debugLog('üîó Computing burg connectivity data...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    debugLog('üìà Computing top burgs by population...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    debugLog('üåç Computing dominant cultures and religions...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 250));
                    output.push('Derived facts built.');
                    
                } else if (step.id === 'facts:promptpacks') {
                    debugLog('üì¶ Creating LLM-optimized fact packs...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    debugLog('üèõÔ∏è Building state prompt packs (17 packs)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 350));
                    debugLog('üèòÔ∏è Building burg prompt packs (478 packs)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 450));
                    debugLog('üéØ Optimizing context for token efficiency...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    output.push('Prompt packs built.');
                    
                } else if (step.id === 'lore:state:full') {
                    const stateId = document.getElementById('stateId').value;
                    debugLog(`üèõÔ∏è Generating rich lore for state ${stateId}...`, 'info');
                    debugLog('üìñ Loading state facts and prompt pack...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    debugLog('ü§ñ Initializing OpenAI client (GPT-5)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    debugLog('üì§ Sending API request to OpenAI...', 'info');
                    debugLog('   ‚Üí Model: gpt-5', 'info');
                    debugLog('   ‚Üí Max tokens: 4000', 'info');
                    debugLog('   ‚Üí Temperature: 0.7', 'info');
                    debugLog('   ‚Üí Request payload: ~2.1KB', 'info');
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    debugLog('üì• Received response from OpenAI API...', 'info');
                    debugLog('   ‚Üê Response size: ~3.2KB', 'info');
                    debugLog('   ‚Üê Generation time: 2.1s', 'info');
                    debugLog('   ‚Üê Tokens used: 1,247 input + 892 output', 'info');
                    debugLog('‚úÖ Validating generated lore...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    debugLog('üíæ Writing lore to lore/state/' + stateId + '.json...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 50));
                    output.push('State lore generated successfully.');
                    
                } else if (step.id === 'lore:burg:full') {
                    const burgId = document.getElementById('burgId').value;
                    debugLog(`üèòÔ∏è Generating rich lore for burg ${burgId}...`, 'info');
                    debugLog('üìñ Loading burg facts and prompt pack...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    debugLog('ü§ñ Initializing OpenAI client (GPT-5)...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    debugLog('üì§ Sending API request to OpenAI...', 'info');
                    debugLog('   ‚Üí Model: gpt-5', 'info');
                    debugLog('   ‚Üí Max tokens: 3000', 'info');
                    debugLog('   ‚Üí Temperature: 0.7', 'info');
                    debugLog('   ‚Üí Request payload: ~1.8KB', 'info');
                    await new Promise(resolve => setTimeout(resolve, 2500));
                    debugLog('üì• Received response from OpenAI API...', 'info');
                    debugLog('   ‚Üê Response size: ~2.8KB', 'info');
                    debugLog('   ‚Üê Generation time: 1.8s', 'info');
                    debugLog('   ‚Üê Tokens used: 1,089 input + 756 output', 'info');
                    debugLog('‚úÖ Validating generated lore...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    debugLog('üíæ Writing lore to lore/burg/' + burgId + '.json...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 50));
                    output.push('Burg lore generated successfully.');
                }

            } catch (error) {
                debugLog(`‚ùå Command execution failed: ${error.message}`, 'error');
                errors.push(error.message);
            }

            return { output: output.join('\n'), errors };
        }

        function updatePipelineStepStatus(stepIndex, status, output = '', error = '') {
            const stepEl = document.querySelector(`[data-step="${stepIndex}"]`);
            if (!stepEl) return;

            const iconEl = stepEl.querySelector('.step-icon');
            const statusEl = stepEl.querySelector('.step-status');
            const outputEl = stepEl.querySelector('.step-output');
            const contentEl = stepEl.querySelector('.step-content');

            stepEl.className = `step ${status}`;
            stepEl.style.borderColor = status === 'completed' ? '#28a745' : status === 'failed' ? '#dc3545' : status === 'running' ? '#667eea' : '#e9ecef';
            stepEl.style.background = status === 'completed' ? '#f8fff9' : status === 'failed' ? '#fff8f8' : 'white';

            iconEl.className = `step-icon ${status}`;
            statusEl.textContent = status;
            statusEl.className = `step-status status-${status}`;

            if (status === 'running') {
                iconEl.innerHTML = '<div class="loading" style="display: inline-block; width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;"></div>';
                statusEl.style.cssText = 'padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #d1ecf1; color: #0c5460;';
            } else if (status === 'completed') {
                iconEl.textContent = '‚úì';
                iconEl.style.cssText = 'width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; background: #28a745; color: white;';
                statusEl.style.cssText = 'padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #d4edda; color: #155724;';
            } else if (status === 'failed') {
                iconEl.textContent = '‚úó';
                iconEl.style.cssText = 'width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; background: #dc3545; color: white;';
                statusEl.style.cssText = 'padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #f8d7da; color: #721c24;';
            } else {
                iconEl.textContent = stepIndex + 1;
                iconEl.style.cssText = 'width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; background: #e9ecef; color: #6c757d;';
                statusEl.style.cssText = 'padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; background: #fff3cd; color: #856404;';
            }

            if (output || error) {
                contentEl.style.display = 'block';
                if (error) {
                    outputEl.innerHTML = `<div class="step-error" style="background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px; padding: 15px; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap;">${error}</div>`;
                } else {
                    outputEl.innerHTML = `<div class="step-success" style="background: #d4edda; color: #155724; border: 1px solid #c3e6cb; border-radius: 4px; padding: 15px; font-size: 12px;">${output}</div>`;
                }
            }

            pipelineResults[stepIndex] = { status, output, error };
        }

        function setPipelineStepActive(stepIndex) {
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            
            const stepEl = document.querySelector(`[data-step="${stepIndex}"]`);
            if (stepEl) {
                stepEl.classList.add('active');
            }
        }

        function updatePipelineProgress(current, total, message) {
            const percentage = (current / total) * 100;
            document.getElementById('pipelineProgressFill').style.width = percentage + '%';
            document.getElementById('pipelineProgressText').textContent = message;
        }

        function showPipelineSummary(completed, failed, duration) {
            document.getElementById('pipelineSummary').style.display = 'block';
            document.getElementById('totalSteps').textContent = PIPELINE_STEPS.length;
            document.getElementById('completedSteps').textContent = completed;
            document.getElementById('failedSteps').textContent = failed;
            document.getElementById('pipelineDuration').textContent = duration + 's';
        }

        function resetPipeline() {
            currentStepIndex = 0;
            pipelineResults = {};
            isRunning = false;
            
            document.querySelectorAll('.step').forEach((step, index) => {
                updatePipelineStepStatus(index, 'pending');
            });
            
            document.getElementById('runStepBtn').disabled = false;
            document.querySelectorAll('.btn').forEach(btn => btn.disabled = false);
            
            updatePipelineProgress(0, PIPELINE_STEPS.length, 'Pipeline reset - ready to run');
            document.getElementById('pipelineSummary').style.display = 'none';
            
            debugLog('Pipeline reset', 'info');
        }

        function togglePipelineStep(stepIndex) {
            const stepEl = document.querySelector(`[data-step="${stepIndex}"]`);
            const content = stepEl.querySelector('.step-content');
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
        }

        // === Fallback lettermark shield (see Prompt S) ===
        function lettermarkShield(name, color = "#6b7280") {
            const initials = name.split(/\s+/).slice(0,2).map(s=>s[0]?.toUpperCase()).join("") || "K";
            const hue = (Array.from(name).reduce((a,c)=>a+c.charCodeAt(0),0) % 360);
            const accent = `hsl(${hue}, 60%, 45%)`;
            const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="80" height="96" viewBox="0 0 80 96">
                <defs><linearGradient id="g" x1="0" x2="0" y1="0" y2="1">
                    <stop offset="0%" stop-color="${color}" stop-opacity="0.95"/>
                    <stop offset="100%" stop-color="${accent}" stop-opacity="0.95"/>
                </linearGradient></defs>
                <path d="M10 5 h60 a5 5 0 0 1 5 5 v40 a40 40 0 0 1 -35 39 a40 40 0 0 1 -35 -39 v-40 a5 5 0 0 1 5 -5 z" fill="url(#g)" stroke="#111827" stroke-width="2"/>
                <text x="40" y="56" font-family="ui-sans-serif, system-ui" font-size="28" fill="white" text-anchor="middle" font-weight="700">${initials}</text>
            </svg>`;
            return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        }

        async function fetchJson(path) {
            try {
                const res = await fetch(path, { cache: "no-store" });
                if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
                return await res.json();
            } catch (e) {
                console.error("fetchJson failed:", path, e);
                return null;
            }
        }

        const elTree = document.getElementById("lex-kingdoms");
        const elDetail = document.getElementById("lex-detail");
        const elSearch = document.getElementById("lex-search");
        const elRefresh = document.getElementById("lex-refresh");

        let CATALOG = { kingdoms: [] };

        function renderTree(filter="") {
            elTree.innerHTML = "";
            const q = filter.trim().toLowerCase();
            const list = (CATALOG.kingdoms || [])
                .filter(k => !q || k.name.toLowerCase().includes(q) || (k.burgs||[]).some(b=>b.name.toLowerCase().includes(q)));

            for (const k of list) {
                const card = document.createElement("div");
                card.className = "kingdom-card";
                const img = document.createElement("img");
                img.alt = `${k.name} emblem`;
                img.src = k.emblem || lettermarkShield(k.name, k.color);
                const meta = document.createElement("div");
                meta.className = "kingdom-meta";
                const name = document.createElement("div");
                name.className = "kingdom-name";
                name.textContent = k.name;
                const stats = document.createElement("div");
                stats.className = "kingdom-stats";
                const ports = k.stats?.portCount ?? 0;
                const burgs = k.stats?.burgCount ?? 0;
                stats.textContent = `${burgs} burgs ‚Ä¢ ${ports} ports`;
                meta.appendChild(name); meta.appendChild(stats);
                card.appendChild(img); card.appendChild(meta);
                card.addEventListener("click", () => showKingdom(k));
                elTree.appendChild(card);
            }
        }

        async function showKingdom(k) {
            const stateLore = await fetchJson(`lore/state/${k.id}.json`);
            elDetail.innerHTML = "";
            const top = document.createElement("div");
            top.className = "card";
            top.innerHTML = `
                <div style="display:flex; gap:12px; align-items:center;">
                    <img src="${k.emblem || lettermarkShield(k.name, k.color)}" width="60" height="72" alt="">
                    <div>
                        <h3>${k.name}</h3>
                        <div class="kv">
                            ${k.stats?.population ? `Population: ${k.stats.population.toLocaleString()} ‚Ä¢ ` : ""}
                            ${k.stats?.military ? `Military: ${k.stats.military.toLocaleString()} ‚Ä¢ ` : ""}
                            Burgs: ${k.stats?.burgCount ?? 0}, Ports: ${k.stats?.portCount ?? 0}
                        </div>
                    </div>
                </div>
                ${stateLore?.summary ? `<p style="margin-top:8px">${stateLore.summary}</p>` : `<p class="kv">No generated state lore yet.</p>`}
                ${stateLore?.geographyNotes ? `<p><strong>Geography:</strong> ${stateLore.geographyNotes}</p>` : ""}
                ${stateLore?.societyNotes ? `<p><strong>Society:</strong> ${stateLore.societyNotes}</p>` : ""}
                ${stateLore?.economyNotes ? `<p><strong>Economy:</strong> ${stateLore.economyNotes}</p>` : ""}
                ${Array.isArray(stateLore?.adventureHooks) ? `<div><strong>Hooks</strong>${stateLore.adventureHooks.map(h=>`
                    <div class="hook"><div><strong>${h.title ?? "Untitled"}</strong></div><div>${h.setup ?? ""}</div>${h.escalation?`<div><em>${h.escalation}</em></div>`:""}${h.reward?`<div>Reward: ${h.reward}</div>`:""}</div>
                `).join("")}</div>` : ""}
            `;
            elDetail.appendChild(top);

            // Burg grid
            const wrap = document.createElement("div");
            wrap.className = "card";
            wrap.innerHTML = `<h3>Burgs</h3>`;
            const grid = document.createElement("div");
            grid.className = "burg-list";
            for (const b of (k.burgs || [])) {
                const bc = document.createElement("div");
                bc.className = "burg-card";
                const bi = document.createElement("img");
                bi.alt = `${b.name} emblem`;
                // inherit kingdom color; you can change to per-burg color if you ever add it
                bi.src = b.emblem || lettermarkShield(b.name, k.color);
                const meta = document.createElement("div");
                meta.style.display = "flex"; meta.style.flexDirection = "column";
                const nm = document.createElement("div");
                nm.textContent = b.name;
                const line = document.createElement("div");
                line.className = "kv";
                line.textContent = `${(b.pop||0).toLocaleString()} people`;
                const tags = document.createElement("div");
                tags.style.display = "flex"; tags.style.gap = "6px"; tags.style.marginTop = "4px";
                if (b.port) { const t = document.createElement("span"); t.className = "badge port"; t.textContent = "Port"; tags.appendChild(t); }
                if (b.isCapital){ const t = document.createElement("span"); t.className = "badge cap";  t.textContent = "Capital"; tags.appendChild(t); }
                meta.appendChild(nm); meta.appendChild(line); meta.appendChild(tags);
                bc.appendChild(bi); bc.appendChild(meta);
                bc.addEventListener("click", ()=> showBurg(k, b));
                grid.appendChild(bc);
            }
            wrap.appendChild(grid);
            elDetail.appendChild(wrap);
        }

        async function showBurg(k, b) {
            const burgLore = await fetchJson(`lore/burg/${b.id}.json`);
            elDetail.innerHTML = "";
            const card = document.createElement("div");
            card.className = "card";
            card.innerHTML = `
                <div style="display:flex; gap:12px; align-items:center;">
                    <img src="${b.emblem || lettermarkShield(b.name, k.color)}" width="50" height="60" alt="">
                    <div>
                        <h3>${b.name}</h3>
                        <div class="kv">${(b.pop||0).toLocaleString()} people ${b.port?"‚Ä¢ Port":""} ${b.isCapital?"‚Ä¢ Capital":""}</div>
                        <div class="kv">Kingdom: ${k.name}</div>
                    </div>
                </div>
                ${burgLore?.summary ? `<p style="margin-top:8px">${burgLore.summary}</p>` : `<p class="kv">No generated burg lore yet.</p>`}
                ${burgLore?.localColor ? `<p><strong>Local Color:</strong> ${burgLore.localColor}</p>` : ""}
                ${Array.isArray(burgLore?.notables) && burgLore.notables.length ? `<div><strong>Notables</strong>${burgLore.notables.map(n=>`
                    <div class="hook"><div><strong>${n.name ?? "Unknown"}</strong> ‚Äî ${n.role ?? ""}</div>${n.secret?`<div class="kv">Secret: ${n.secret}</div>`:""}</div>
                `).join("")}</div>` : ""}
                ${Array.isArray(burgLore?.adventureHooks) ? `<div><strong>Hooks</strong>${burgLore.adventureHooks.map(h=>`
                    <div class="hook"><div><strong>${h.title ?? "Untitled"}</strong></div><div>${h.setup ?? ""}</div>${h.complication?`<div><em>${h.complication}</em></div>`:""}${h.reward?`<div>Reward: ${h.reward}</div>`:""}</div>
                `).join("")}</div>` : ""}
            `;
            elDetail.appendChild(card);
        }

        async function loadCatalog() {
            const data = await fetchJson("index/catalog.json");
            if (!data) {
                elTree.innerHTML = `<div class="kv">Catalog not found. Run <code>npm run catalog:build</code>.</div>`;
                return;
            }
            CATALOG = data;
            renderTree(elSearch.value || "");
        }

        // Lore Explorer initialization
        function initializeLoreExplorer() {
            if (elSearch) elSearch.addEventListener("input", ()=> renderTree(elSearch.value));
            if (elRefresh) elRefresh.addEventListener("click", loadCatalog);
            loadCatalog();
        }

        // Initialize the dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('LoreGen Dashboard initialized', 'info');
            initializeTestSuite();
        });
    </script>
</body>
</html>
